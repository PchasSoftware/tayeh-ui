<template>
  <div class="ty-color-picker-wrapper m-0" dir="ltr">
    <v-ctrl direction="vh" :precision="2" :throttle="80" @change="onSaturationChange">
      <div class="ty-color-picker-v-ctrl ty-color-picker-saturation">
        <div class="msk-hue" :style="styles.saturationPane"></div>
        <div class="msk-white"></div>
        <div class="msk-black"></div>
        <p class="ty-color-picker-thumb" :style="styles.saturationThumb"></p>
      </div>
    </v-ctrl>

    <div class="ty-color-picker-ctrl-pane">
      <div>
        <div class="ty-color-picker-preview">
          <div :style="styles.preview"></div>
        </div>

        <div class="ty-color-picker-tracks">
          <v-ctrl direction="h" :precision="2" :throttle="80" @change="onHueChange">
            <div class="ty-color-picker-v-ctrl ty-color-picker-ctrl-bar ty-color-picker-ctrl-hue">
              <div class="ty-color-picker-thumb" :style="styles.hueThumb"></div>
            </div>
          </v-ctrl>

          <v-ctrl direction="h" :precision="2" :throttle="80" @change="onAlphaChange">
            <div class="ty-color-picker-v-ctrl ty-color-picker-ctrl-alpha">
              <div class="ty-color-picker-thumb" :style="styles.alphaThumb"></div>
              <div class="ty-color-picker-ctrl-bar" :style="styles.alphaTrack"></div>
            </div>
          </v-ctrl>
        </div>
      </div>

      <div style="margin-top: 10px">
        <div class="ty-color-picker-fm-fields" dir="ltr">
          <div v-for="k in colorModes['hex']" :key="k">
            <div style="position: relative;">
              <input @change="handleInput(k, $event)" :value="colorModel[k]" :type="constrains[k].type"
                :maxlength="constrains[k].maxlength">
              <span>{{k}}</span>
            </div>
          </div>
        </div>

        <!-- <div class="ty-color-picker-fm-switcher">
          <div @click="changecurrentMode()">
            <svg viewBox="0 0 24 24">
              <path fill="#333" d="M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" />
              <path fill="#333" d="M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15Z" />
            </svg>
        </div>
      </div> -->
      </div>
    </div>
  </div>
</template>

<script>
  import clamp from '../../utils/clamp'
  import debounce from '../../utils/debounce'
  import objectAssign from 'object-assign'
  import parse2rgb from 'pure-color/parse'
  import rgb2hsv from 'pure-color/convert/rgb2hsv'
  import rgb2hex from 'pure-color/convert/rgb2hex'
  import hsv2rgb from 'pure-color/convert/hsv2rgb'
  import hsl2rgb from 'pure-color/convert/hsl2rgb'
  import VCtrl from 'v-ctrl'
  const colorModes = Object.freeze({
    hex: ['hex']
  })
  export default {
    name: 'ty-color-picker',
    props: {
      value: {
        type: String,
        default: '#ff0000'
      }
    },
    components: {
      'v-ctrl': VCtrl.VueCtrlComponent
    },
    data() {
      const {
        value
      } = this
      const commonNumber = {
        type: 'number',
        maxlength: 3,
      }
      const percentValue = {
        type: 'string',
        maxlength: 4
      }
      return {
        ...this.digestProp(value),
        currentMode: 'hex',
        colorModes,
        colorModel: {
          hex: ''
        },
        constrains: {
          hex: {
            type: 'string',
            maxlength: 9
          }
        }
      }
    },
    watch: {
      value: {
        immediate: true,
        handler(newVal, oldVal) {
          if (newVal !== oldVal) {
            objectAssign(this, this.digestProp(newVal))
          }
        }
      },
      hex: {
        immediate: true,
        handler(newVal, oldVal) {
          if (`${newVal}` !== `${oldVal}`) {
            this.emitChange()
          }
        }
      }
    },
    computed: {
      hsva() {
        const {
          hue,
          alpha,
          saturation: {
            x,
            y
          }
        } = this
        return [
          hue * 360,
          x * 100,
          (1 - y) * 100,
          alpha
        ]
      },
      rgba() {
        const {
          alpha,
          hsva
        } = this
        const [r, g, b] = hsv2rgb(hsva)
        return [
          Math.round(r),
          Math.round(g),
          Math.round(b),
          alpha
        ]
      },
      hex() {
        return rgb2hex(this.rgba)
      },
      previewBorderColor() {
        const [r, g, b] = this.rgba
        if ((r + g + b) / 3 > 235) {
          return `rgba(160,160,160,0.8)`
        }
        return 'transparent'
      },
      styles() {
        const {
          rgba,
          alpha,
          hue,
          saturation
        } = this
        const strRGB = rgba.slice(0, 3).join(', ')
        const strHueRGB = hsl2rgb([hue * 360, 100, 50])
          .map(v => Math.round(v))
          .join(', ')
        return {
          preview: {
            backgroundColor: `rgba(${rgba.join(', ')})`,
            borderColor: this.previewBorderColor
          },
          saturationPane: {
            backgroundColor: `rgb(${strHueRGB})`
          },
          saturationThumb: {
            left: toPercent(saturation.x),
            top: toPercent(saturation.y)
          },
          alphaTrack: {
            backgroundImage: `linear-gradient(to right, ` +
              `rgba(${strRGB}, 0) 0%, rgb(${strRGB}) 100%)`
          },
          alphaThumb: {
            left: toPercent(alpha)
          },
          hueThumb: {
            left: toPercent(1 - hue)
          }
        }
      }
    },
    methods: {
      digestProp(val) {
        const rgba = parse2rgb(val)
        const alpha = rgba[3] == null ? 1 : rgba[3]
        const [hue, saturation, value] = rgb2hsv(rgba)
        // format of alpha: `.2f`
        // according to Chrome DevTool
        const _alpha = parseFloat(alpha.toFixed(2))
        return {
          alpha: _alpha,
          hue: hue / 360,
          saturation: {
            x: saturation / 100,
            y: 1 - value / 100
          }
        }
      },
      onSaturationChange([x, y]) {
        this.saturation = {
          x,
          y
        }
      },
      onHueChange(e) {
        this.hue = 1 - e
      },
      onAlphaChange(e) {
        // format of alpha: `.2f`
        // according to Chrome DevTool
        this.alpha = parseFloat(e.toFixed(2))
      },
      emitChange() {
        const {
          alpha,
          hex,
          rgba
        } = this
        const hexVal = simplifyHex(
          alpha === 1 ? hex.slice(0, 7) : hex
        )
        this.$emit('input', hexVal)
        this.$emit('change', hexVal)
        // this ensures that every component in
        // our model is up to date
        const [r, g, b] = rgba
        const shortHex = objectAssign(this.colorModel, {
          r,
          g,
          b,
          a: alpha,
          hex: hexVal
        })
      },
      changecurrentMode() {
        const modes = Object.keys(this.colorModes)
        const index = modes.indexOf(this.currentMode)
        this.currentMode = modes[(index + 1) % modes.length]
      },
      handleInput(type, event) {
        const {
          currentMode,
          colorModel
        } = this
        const {
          target: {
            value
          }
        } = event
        let num = Number(value)
        let changed = false
        switch (type) {
          case 'a':
            if (colorModel[type] !== num && !isNaN(num)) {
              colorModel[type] = clamp(num, 0, 1)
              changed = true
            }
            break
          case 'r':
          case 'g':
          case 'b':
            if (colorModel[type] !== num && !isNaN(num)) {
              colorModel[type] = clamp(num, 0, 255) | 0
              changed = true
            }
            break
          case 'hex':
            if (value[0] === '#') {
              if (colorModel[type] !== value && parse2rgb(value).every(i => !isNaN(i))) {
                colorModel[type] = simplifyHex(value)
                changed = true
              }
            }
            break
        }
        if (changed) {
          const {
            r,
            g,
            b,
            a,
            hex
          } = colorModel
          let literal = hex
          objectAssign(this, this.digestProp(literal))
        }
      }
    },
    created() {
      this.handleInput = debounce(this.handleInput.bind(this), 50)
    }
  }

  function toPercent(n, precision = 3) {
    // eslint-disable-next-line
    const num = (n * 100).toPrecision(precision | 0)
    return `${num}%`
  }

  function simplifyHex(val) {
    return val.replace(/#([0-9a-f])\1([0-9a-f])\2([0-9a-f])\3([0-9a-f]?)\4$/, '#$1$2$3$4')
  }
</script>